@page "/mobile/execute/{RoundId:guid}"
@using Microsoft.Extensions.Localization
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using SBAPro.Core.Entities
@using SBAPro.Core.Interfaces
@using SBAPro.Infrastructure.Data
@attribute [Authorize(Roles = "Inspector,TenantAdmin,SystemAdmin")]
@layout MobileLayout
@rendermode InteractiveServer
@inject IStringLocalizer<SharedResources> Localizer
@inject NavigationManager NavigationManager
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject ITenantService TenantService
@implements IDisposable

<div class="mobile-execute">
    @* Offline/Sync Status Indicator *@
    <div class="sync-status @(isOnline ? "online" : "offline")" @onclick="CheckSyncStatus">
        @if (!isOnline)
        {
            <span class="status-icon">üì°</span>
            <span class="status-text">@Localizer["OfflineMode"]</span>
            @if (pendingCount > 0)
            {
                <span class="pending-badge">@pendingCount</span>
            }
        }
        else if (pendingCount > 0)
        {
            <span class="status-icon">üîÑ</span>
            <span class="status-text">@Localizer["SyncPending"] (@pendingCount)</span>
        }
        else
        {
            <span class="status-icon">‚úì</span>
            <span class="status-text">@Localizer["Online"]</span>
        }
    </div>

    @if (isLoading)
    {
        <div class="loading">
            <p>@Localizer["LoadingInspectionRound"]...</p>
        </div>
    }
    else if (inspectionRound == null)
    {
        <div class="error">
            <p>@Localizer["InspectionRoundNotFound"]</p>
        </div>
    }
    else
    {
        <div class="round-info">
            <h2>@inspectionRound.Site.Name</h2>
            
            @if (floorPlans.Count > 1)
            {
                <div class="form-group">
                    <label>@Localizer["SelectFloor"]</label>
                    <select @bind="selectedFloorPlanId" @bind:after="FilterObjectsByFloor" class="form-select">
                        <option value="@Guid.Empty">@Localizer["AllFloors"]</option>
                        @foreach (var fp in floorPlans)
                        {
                            <option value="@fp.Id">@fp.Name</option>
                        }
                    </select>
                </div>
            }
            
            <div class="progress-bar">
                <div class="progress-fill" style="width: @GetProgressPercentage()%"></div>
            </div>
            <p class="progress-text">
                @inspectedCount / @totalObjects @Localizer["ObjectsInspected"]
            </p>
        </div>

        <div class="objects-list">
            @foreach (var obj in filteredObjects)
            {
                var result = GetInspectionResult(obj.Id);
                var isInspected = result != null;
                
                <div class="object-card @(isInspected ? "inspected" : "")" @onclick="() => OpenInspectionModal(obj)">
                    <div class="object-status">
                        @if (isInspected)
                        {
                            <span class="status-icon @GetStatusIconClass(result.Status)">
                                @GetStatusIcon(result.Status)
                            </span>
                        }
                        else
                        {
                            <span class="status-icon pending">‚ö™</span>
                        }
                    </div>
                    <div class="object-info">
                        <h3>@obj.Description</h3>
                        <p class="object-type">@obj.Type.Name</p>
                        @if (isInspected && !string.IsNullOrWhiteSpace(result.Comment))
                        {
                            <p class="object-comment">@result.Comment</p>
                        }
                    </div>
                    <div class="object-action">
                        <span class="action-icon">@(isInspected ? "‚úèÔ∏è" : "‚ñ∂Ô∏è")</span>
                    </div>
                </div>
            }
        </div>
    }
</div>

@if (showModal && selectedObject != null)
{
    <div class="modal-overlay" @onclick="CloseModal">
        <div class="modal-content" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3>@selectedObject.Description</h3>
                <button type="button" class="close-btn" @onclick="CloseModal">‚úï</button>
            </div>
            
            <div class="modal-body">
                <div class="form-group">
                    <label>@Localizer["Status"]</label>
                    <div class="status-buttons">
                        <button type="button" class="status-btn @(inspectionStatus == InspectionStatus.Ok ? "active ok" : "")"
                                @onclick='() => SetStatus(InspectionStatus.Ok)'>
                            <span class="btn-icon">‚úÖ</span>
                            <span>@Localizer["Ok"]</span>
                        </button>
                        <button type="button" class="status-btn @(inspectionStatus == InspectionStatus.Deficient ? "active deficient" : "")"
                                @onclick='() => SetStatus(InspectionStatus.Deficient)'>
                            <span class="btn-icon">‚ö†Ô∏è</span>
                            <span>@Localizer["Deficient"]</span>
                        </button>
                        <button type="button" class="status-btn @(inspectionStatus == InspectionStatus.NotAccessible ? "active not-accessible" : "")"
                                @onclick='() => SetStatus(InspectionStatus.NotAccessible)'>
                            <span class="btn-icon">üö´</span>
                            <span>@Localizer["NotAccessible"]</span>
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label>@Localizer["Comment"] (@Localizer["Optional"])</label>
                    <textarea @bind="inspectionComment" 
                              rows="4" 
                              placeholder="@Localizer["EnterComment"]"></textarea>
                </div>

                <div class="form-group">
                    <label>@Localizer["Photos"] (@Localizer["Optional"])</label>
                    
                    @if (photos.Any())
                    {
                        <div class="photos-grid">
                            @foreach (var photo in photos)
                            {
                                <div class="photo-preview-item">
                                    <img src="@GetPhotoDataUrl(photo.PhotoData, photo.PhotoMimeType)" alt="Inspection photo" />
                                    <button type="button" class="btn-remove-photo-small" @onclick="() => RemovePhoto(photo)">
                                        ‚úï
                                    </button>
                                </div>
                            }
                        </div>
                    }
                    
                    <InputFile OnChange="HandlePhotoSelected" accept="image/*" capture="environment" multiple class="file-input" />
                    
                    @if (!string.IsNullOrEmpty(photoUploadMessage))
                    {
                        <div class="upload-message">@photoUploadMessage</div>
                    }
                </div>
            </div>

            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" @onclick="CloseModal">
                    @Localizer["Cancel"]
                </button>
                <button type="button" class="btn btn-primary" @onclick="SaveInspection" disabled="@(inspectionStatus == null)">
                    @Localizer["SaveInspection"]
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public Guid RoundId { get; set; }

    private InspectionRound? inspectionRound;
    private List<InspectionObject> objects = new();
    private List<InspectionObject> filteredObjects = new();
    private List<FloorPlan> floorPlans = new();
    private List<InspectionResult> results = new();
    private bool isLoading = true;
    private int inspectedCount = 0;
    private int totalObjects = 0;
    private Guid selectedFloorPlanId = Guid.Empty;

    private bool showModal = false;
    private InspectionObject? selectedObject;
    private InspectionStatus? inspectionStatus;
    private string? inspectionComment;
    private List<PhotoItem> photos = new();
    private List<PhotoItem> photosToDelete = new();
    private string? photoUploadMessage;
    
    // Offline support
    private bool isOnline = true;
    private int pendingCount = 0;
    private System.Threading.Timer? syncTimer;

    private class PhotoItem
    {
        public Guid? Id { get; set; } // Null for new photos
        public byte[] PhotoData { get; set; } = null!;
        public string PhotoMimeType { get; set; } = null!;
        public bool IsNew { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadInspectionRound();
        await CheckOnlineStatus();
        
        // Start periodic sync status check (every 5 seconds)
        syncTimer = new System.Threading.Timer(async _ => 
        {
            await InvokeAsync(async () =>
            {
                await CheckOnlineStatus();
                StateHasChanged();
            });
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }

    private async Task CheckOnlineStatus()
    {
        // Check network status (simplified - in production use JS interop for navigator.onLine)
        isOnline = true; // Default to online
        
        // Check pending count from IndexedDB (would need JS interop in full implementation)
        // await JSRuntime.InvokeAsync<int>("offlineStorage.getPendingCount");
        pendingCount = 0;
    }

    private async Task CheckSyncStatus()
    {
        await CheckOnlineStatus();
        
        if (isOnline && pendingCount > 0)
        {
            // Trigger background sync (would need proper API endpoint)
            Console.WriteLine($"[Execute] Would sync {pendingCount} pending items");
            
            // In full implementation:
            // await JSRuntime.InvokeVoidAsync("navigator.serviceWorker.ready.then", "r => r.sync.register('sync-inspections')");
        }
    }

    public void Dispose()
    {
        syncTimer?.Dispose();
    }

    private async Task LoadInspectionRound()
    {
        isLoading = true;
        try
        {
            using var context = await DbFactory.CreateDbContextAsync();
            
            inspectionRound = await context.InspectionRounds
                .Include(r => r.Site)
                .ThenInclude(s => s.FloorPlans)
                .ThenInclude(fp => fp.InspectionObjects)
                .ThenInclude(o => o.Type)
                .Include(r => r.InspectionResults)
                .ThenInclude(res => res.Photos)
                .FirstOrDefaultAsync(r => r.Id == RoundId);

            if (inspectionRound != null)
            {
                floorPlans = inspectionRound.Site.FloorPlans.OrderBy(fp => fp.Name).ToList();
                
                objects = inspectionRound.Site.FloorPlans
                    .SelectMany(fp => fp.InspectionObjects)
                    .OrderBy(o => o.Description)
                    .ToList();

                FilterObjectsByFloor();

                results = inspectionRound.InspectionResults.ToList();
                totalObjects = filteredObjects.Count;
                inspectedCount = results.Count(r => filteredObjects.Any(o => o.Id == r.ObjectId));
            }
        }
        finally
        {
            isLoading = false;
        }
    }

    private InspectionResult? GetInspectionResult(Guid objectId)
    {
        return results.FirstOrDefault(r => r.ObjectId == objectId);
    }

    private void OpenInspectionModal(InspectionObject obj)
    {
        selectedObject = obj;
        var existingResult = GetInspectionResult(obj.Id);
        inspectionStatus = existingResult?.Status;
        inspectionComment = existingResult?.Comment;
        
        // Load existing photos from Photos collection (new) and legacy PhotoData (old)
        photos.Clear();
        photosToDelete.Clear();
        
        if (existingResult != null)
        {
            // Load from new Photos collection
            if (existingResult.Photos != null && existingResult.Photos.Any())
            {
                foreach (var photo in existingResult.Photos)
                {
                    photos.Add(new PhotoItem
                    {
                        Id = photo.Id,
                        PhotoData = photo.PhotoData,
                        PhotoMimeType = photo.PhotoMimeType,
                        IsNew = false
                    });
                }
            }
            // Fallback to legacy single photo if exists
            else if (existingResult.PhotoData != null && existingResult.PhotoMimeType != null)
            {
                photos.Add(new PhotoItem
                {
                    Id = null, // Legacy photo doesn't have ID
                    PhotoData = existingResult.PhotoData,
                    PhotoMimeType = existingResult.PhotoMimeType,
                    IsNew = false
                });
            }
        }
        
        photoUploadMessage = null;
        showModal = true;
    }

    private void SetStatus(InspectionStatus status)
    {
        inspectionStatus = status;
        StateHasChanged();
    }

    private void CloseModal()
    {
        showModal = false;
        selectedObject = null;
        inspectionStatus = null;
        inspectionComment = null;
        photos.Clear();
        photosToDelete.Clear();
        photoUploadMessage = null;
    }

    private async Task SaveInspection()
    {
        if (selectedObject == null || inspectionStatus == null)
            return;

        try
        {
            using var context = await DbFactory.CreateDbContextAsync();
            
            var existingResult = await context.InspectionResults
                .Include(r => r.Photos)
                .FirstOrDefaultAsync(r => r.RoundId == RoundId && r.ObjectId == selectedObject.Id);

            if (existingResult != null)
            {
                existingResult.Status = inspectionStatus.Value;
                existingResult.Comment = inspectionComment;
                existingResult.Timestamp = DateTime.UtcNow;
                
                // Handle photo deletions
                foreach (var photoToDelete in photosToDelete.Where(p => p.Id.HasValue))
                {
                    var photoEntity = existingResult.Photos.FirstOrDefault(p => p.Id == photoToDelete.Id);
                    if (photoEntity != null)
                    {
                        context.InspectionPhotos.Remove(photoEntity);
                    }
                }
                
                // Add new photos directly to the context
                foreach (var newPhoto in photos.Where(p => p.IsNew))
                {
                    var photoEntity = new InspectionPhoto
                    {
                        Id = Guid.NewGuid(),
                        InspectionResultId = existingResult.Id,
                        PhotoData = newPhoto.PhotoData,
                        PhotoMimeType = newPhoto.PhotoMimeType,
                        UploadedAt = DateTime.UtcNow
                    };
                    context.InspectionPhotos.Add(photoEntity);
                }
                
                context.InspectionResults.Update(existingResult);
            }
            else
            {
                var newResult = new InspectionResult
                {
                    Id = Guid.NewGuid(),
                    RoundId = RoundId,
                    ObjectId = selectedObject.Id,
                    Status = inspectionStatus.Value,
                    Comment = inspectionComment,
                    Timestamp = DateTime.UtcNow
                };
                
                // Add photos to new result
                foreach (var photo in photos.Where(p => p.IsNew))
                {
                    newResult.Photos.Add(new InspectionPhoto
                    {
                        Id = Guid.NewGuid(),
                        InspectionResultId = newResult.Id,
                        PhotoData = photo.PhotoData,
                        PhotoMimeType = photo.PhotoMimeType,
                        UploadedAt = DateTime.UtcNow
                    });
                }
                
                context.InspectionResults.Add(newResult);
            }

            var changesSaved = await context.SaveChangesAsync();
            Console.WriteLine($"SaveInspection: {changesSaved} changes saved");
            
            CloseModal();
            await LoadInspectionRound();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error saving inspection: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
        }
    }

    private double GetProgressPercentage()
    {
        return totalObjects > 0 ? (inspectedCount * 100.0 / totalObjects) : 0;
    }

    private string GetStatusIconClass(InspectionStatus status)
    {
        return status switch
        {
            InspectionStatus.Ok => "ok",
            InspectionStatus.Deficient => "deficient",
            InspectionStatus.NotAccessible => "not-accessible",
            _ => ""
        };
    }

    private string GetStatusIcon(InspectionStatus status)
    {
        return status switch
        {
            InspectionStatus.Ok => "‚úÖ",
            InspectionStatus.Deficient => "‚ö†Ô∏è",
            InspectionStatus.NotAccessible => "üö´",
            _ => "‚ö™"
        };
    }

    private void FilterObjectsByFloor()
    {
        if (selectedFloorPlanId == Guid.Empty)
        {
            filteredObjects = objects.ToList();
        }
        else
        {
            filteredObjects = objects.Where(o => o.FloorPlanId == selectedFloorPlanId).ToList();
        }
        
        totalObjects = filteredObjects.Count;
        inspectedCount = results.Count(r => filteredObjects.Any(o => o.Id == r.ObjectId));
    }

    private async Task HandlePhotoSelected(InputFileChangeEventArgs e)
    {
        photoUploadMessage = null;
        
        try
        {
            var filesProcessed = 0;
            var filesFailed = 0;
            
            foreach (var file in e.GetMultipleFiles(10))
            {
                if (file.Size > 5 * 1024 * 1024) // 5MB limit per file
                {
                    filesFailed++;
                    continue;
                }

                using var memoryStream = new MemoryStream();
                await file.OpenReadStream(maxAllowedSize: 5 * 1024 * 1024).CopyToAsync(memoryStream);
                
                photos.Add(new PhotoItem
                {
                    Id = null,
                    PhotoData = memoryStream.ToArray(),
                    PhotoMimeType = file.ContentType,
                    IsNew = true
                });
                
                filesProcessed++;
            }
            
            if (filesProcessed > 0)
            {
                photoUploadMessage = filesProcessed == 1 
                    ? Localizer["PhotoUploaded"] 
                    : $"{filesProcessed} {Localizer["PhotosUploaded"]}";
            }
            
            if (filesFailed > 0)
            {
                photoUploadMessage += $" ({filesFailed} {Localizer["PhotosTooLarge"]})";
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            photoUploadMessage = $"{Localizer["PhotoUploadFailed"]}: {ex.Message}";
            Console.WriteLine($"Photo upload error: {ex.Message}");
        }
    }

    private void RemovePhoto(PhotoItem photo)
    {
        if (!photo.IsNew && photo.Id.HasValue)
        {
            photosToDelete.Add(photo);
        }
        photos.Remove(photo);
        photoUploadMessage = Localizer["PhotoRemoved"];
        StateHasChanged();
    }

    private string GetPhotoDataUrl(byte[] photoData, string photoMimeType)
    {
        if (photoData != null && !string.IsNullOrEmpty(photoMimeType))
        {
            var base64 = Convert.ToBase64String(photoData);
            return $"data:{photoMimeType};base64,{base64}";
        }
        return string.Empty;
    }
}
